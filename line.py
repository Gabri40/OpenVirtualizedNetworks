import numpy as np
from scipy.constants import c, h, pi

from node import *

class Line(object):
    def __init__(self, line_dict):
        self._label = line_dict['label']
        self._length = line_dict['length']
        self._successive = {}
        self._state=["free"]*10

        self._n_amplifiers = int(self._length / 80e3) + 2 # uno/80km + 1/terminale
        self._gain = 16
        self._noise_figure = 5
        self._noise_figure = 3 # DEFAULT

        self.alpha = 0.2e-3
        self.beta2 = 0.6e-26
        self.beta2 = 2.13e-26 # DEFAULT

        self.gamma = 1.27e-3
        self.Rs=32e9
        self.df=50e9


    @property
    def n_amplifiers(self):
        return self._n_amplifiers

    @n_amplifiers.setter
    def n_amplifiers(self, value):
        self._n_amplifiers = value

    @property
    def gain(self):
        return self._gain

    @property
    def label(self):
        return self._label

    @property
    def length(self):
        return self._length

    @property
    def successive(self):
        return self._successive
    @successive.setter
    def successive(self, successive):
        self._successive = successive

    @property
    def state(self):
        return self._state
    @state.setter
    def state(self,state,channel):
        self._state[channel]=state

    @property
    def n_amplifiers(self):
        return self._n_amplifiers

    @n_amplifiers.setter
    def n_amplifiers(self, value):
        self._n_amplifiers = value

    @property
    def gain(self):
        return self._gain

    def latency_generation(self):
        latency = self.length /(3e8 * 2 / 3)
        return latency


    def noise_generation(self, lightpath):
        # noise=1e-9*signal_power*self.length
        noise = self.ase_generation() + self.nli_generation(lightpath.signal_power, lightpath.df, lightpath.Rs)
        return noise


    def probe(self, signal_information,busy=False):
        sp = self.optimized_launch_power(self.eta_nli(lightpath.df, lightpath.Rs))
        lightpath.set_signal_power(sp)

        # Update latency
        latency = self.latency_generation()
        signal_information.add_latency(latency)

        # Update noise
        signal_power = signal_information.signal_power
        noise = self.noise_generation(lightpath)
        signal_information.add_noise(noise)

        # print("prop: "+str(self.label))
        node = self.successive[signal_information.path[0]]
        signal_information = node.propagate(signal_information,busy)
        return signal_information

    def propagate(self, lightpath,busy):

        sp = self.optimized_launch_power(self.eta_nli(lightpath.df, lightpath.Rs))
        lightpath.set_signal_power(sp)
        # print(sp)

        # Update latency
        latency = self.latency_generation()
        lightpath.add_latency(latency)

        # Update noise
        signal_power = lightpath.signal_power
        noise = self.noise_generation(lightpath)
        lightpath.add_noise(noise)

        if busy: self._states[lightpath.channel]="occupied"

        # print("prop: "+str(self.label))
        node = self.successive[lightpath.path[0]]
        lightpath = node.propagate(lightpath,busy)
        return lightpath


# evaluate the to tal amount of amplified spontaneous emissions (ASE) in linear units
# generated by the amplifiers supposing that a cascade of amplifiers introduces
# a noise amount which follows the expression:
#       ASE = N * (h * f * B_n * NF * [G − 1] )
# where N is the number of amplifiers, h is the Plank constant, f is the
# frequency which would be fixed to 193.414 THz (C-band center), Bn is
# the noise bandwidth fixed to 12.5 GHz, NF and G are the amplifier noise
# figure and gain, respectively
    def ase_generation(self):
        NF = 10 ** (self._noise_figure / 10)
        G = 10 ** (self._gain / 10)
        f = 193.414e12
        Bn = 12.5e9  # GHz
        ASE = self._n_amplifiers * h * f * Bn * NF * (G - 1)
        return ASE


# evaluates the total amount generated by the nonlinear interface noise using the formula
# (in linear units):        NLI = P_ch^3 * η_nli * N_span * Bn
# where Bn is the noise bandwidth (12.5 GHz) and Nspan is the number of
# fiber span within the considered line
    def nli_generation(self, signal_power, dfp, Rsp):
        Bn = 12.5e9  # GHz
        eta_nli = self.eta_nli(dfp, Rsp)
        nli = (signal_power ** 3) * eta_nli * self._n_amplifiers * Bn
        return nli
    def eta_nli(self, dfp, Rsp):
        df = dfp
        Rs = Rsp
        a = self.alpha / (20 * np.log10(np.e))
        Nch = 10
        b2 = self.beta2
        e_nli = 16 / (27 * np.pi) * np.log(
            np.pi ** 2 * b2 * Rs ** 2 * Nch ** (2 * Rs / df) / (2 * a)) * self.gamma ** 2 / (
                        4 * a * b2 * Rs ** 3)

        return e_nli


# Determination of the optimal launch power.
# Hint: start from the definition of the GSNR and introduce the expressions
# of ASE and NLI power adopted
    def optimized_launch_power(self, eta):
        F = 10 ** (self._noise_figure / 10)
        G = 10 ** (self._gain / 10)
        f0 = 193.414e12
        olp = ((F * f0 * h * G) / (2 * eta)) ** (1 / 3)
        return olp


